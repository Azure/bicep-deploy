{
  "version": 3,
  "sources": ["../src/whatif.ts", "../src/logging.ts"],
  "sourcesContent": ["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport {\n  ChangeType,\n  PropertyChangeType,\n  WhatIfChange,\n  WhatIfOperationResult,\n  WhatIfPropertyChange,\n} from \"@azure/arm-resources\";\nimport { Color, ColorMode, ColorStringBuilder } from \"./logging\";\n\n// ChatGPT was heavily utilized to generate this file, using the below Python code as a starting point:\n// https://github.com/Azure/azure-cli/blob/5b77a09013d0f15f01e2b2acce1efd37571ac1d9/src/azure-cli/azure/cli/command_modules/resource/_formatters.py#L84\n\ntype UnknownValue = unknown;\n\nenum Symbol {\n  WhiteSpace = \" \",\n  Quote = '\"',\n  Colon = \":\",\n  LeftSquareBracket = \"[\",\n  RightSquareBracket = \"]\",\n  Dot = \".\",\n  Equal = \"=\",\n  Asterisk = \"*\",\n  Plus = \"+\",\n  Minus = \"-\",\n  Tilde = \"~\",\n  ExclamationPoint = \"!\",\n  Cross = \"x\",\n}\n\nconst changeTypeToColor: Record<ChangeType, Color> = {\n  Create: Color.Green,\n  Delete: Color.Red,\n  Modify: Color.Magenta,\n  Deploy: Color.Blue,\n  NoChange: Color.Reset,\n  Ignore: Color.White,\n  Unsupported: Color.White,\n};\n\nconst propertyChangeTypeToColor: Record<PropertyChangeType, Color> = {\n  Create: Color.Green,\n  Delete: Color.Red,\n  Modify: Color.Magenta,\n  Array: Color.Magenta,\n  NoEffect: Color.White,\n};\n\nconst changeTypeToSymbol: Record<ChangeType, Symbol> = {\n  Create: Symbol.Plus,\n  Delete: Symbol.Minus,\n  Modify: Symbol.Tilde,\n  Deploy: Symbol.ExclamationPoint,\n  NoChange: Symbol.Equal,\n  Ignore: Symbol.Asterisk,\n  Unsupported: Symbol.Cross,\n};\n\nconst propertyChangeTypeToSymbol: Record<PropertyChangeType, Symbol> = {\n  Create: Symbol.Plus,\n  Delete: Symbol.Minus,\n  Modify: Symbol.Tilde,\n  Array: Symbol.Tilde,\n  NoEffect: Symbol.Cross,\n};\n\nconst changeTypeToWeight: Record<ChangeType, number> = {\n  Delete: 0,\n  Create: 1,\n  Deploy: 2,\n  Modify: 3,\n  NoChange: 4,\n  Unsupported: 5,\n  Ignore: 6,\n};\n\nconst propertyChangeTypeToWeight: Record<PropertyChangeType, number> = {\n  Delete: 0,\n  Create: 1,\n  Modify: 2,\n  Array: 2,\n  NoEffect: 3,\n};\n\nconst propertyChangeToChangeType: Record<PropertyChangeType, ChangeType> = {\n  Array: \"Modify\",\n  Create: \"Create\",\n  Delete: \"Delete\",\n  Modify: \"Modify\",\n  NoEffect: \"NoChange\",\n};\n\nexport function formatJson(value: UnknownValue, colorMode: ColorMode): string {\n  const builder = new ColorStringBuilder(colorMode);\n  formatJsonValue(builder, value);\n  return builder.build();\n}\n\nexport function formatWhatIfOperationResult(\n  whatIfOperationResult: WhatIfOperationResult,\n  colorMode: ColorMode,\n): string {\n  const builder = new ColorStringBuilder(colorMode);\n  formatNoiseNotice(builder);\n  formatChangeTypeLegend(builder, whatIfOperationResult.changes ?? []);\n  formatResourceChanges(builder, whatIfOperationResult.changes ?? []);\n  formatResourceChangesStats(builder, whatIfOperationResult.changes ?? []);\n  return builder.build();\n}\n\nfunction formatNoiseNotice(builder: ColorStringBuilder): void {\n  builder.appendLine(`Note: The result may contain false positive predictions (noise).\nYou can help us improve the accuracy of the result by opening an issue here: https://aka.ms/WhatIfIssues`);\n  builder.appendLine();\n}\n\nfunction formatChangeTypeLegend(\n  builder: ColorStringBuilder,\n  resourceChanges: WhatIfChange[],\n): void {\n  if (!resourceChanges.length) return;\n\n  const changeTypeSet = new Set<ChangeType>();\n\n  function populateChangeTypeSet(\n    propertyChanges: WhatIfPropertyChange[],\n  ): void {\n    if (!propertyChanges.length) return;\n\n    for (const propertyChange of propertyChanges) {\n      const propertyChangeType = propertyChange.propertyChangeType;\n      changeTypeSet.add(propertyChangeToChangeType[propertyChangeType]);\n      populateChangeTypeSet(propertyChange.children ?? []);\n    }\n  }\n\n  for (const resourceChange of resourceChanges) {\n    changeTypeSet.add(resourceChange.changeType);\n    populateChangeTypeSet(resourceChange.delta ?? []);\n  }\n\n  const changeTypes = Array.from(changeTypeSet).sort(\n    (a, b) => changeTypeToWeight[a] - changeTypeToWeight[b],\n  );\n\n  builder.append(\"Resource and property changes are indicated with \");\n  builder.appendLine(\n    changeTypes.length === 1 ? \"this symbol:\" : \"these symbols:\",\n  );\n\n  for (const changeType of changeTypes) {\n    const changeTypeSymbol = changeTypeToSymbol[changeType];\n    const changeTypeColor = changeTypeToColor[changeType];\n    formatIndent(builder);\n    builder.append(changeTypeSymbol, changeTypeColor).append(Symbol.WhiteSpace);\n    builder.appendLine(\n      changeType.charAt(0).toUpperCase() + changeType.slice(1),\n    );\n  }\n}\n\nfunction formatResourceChangesStats(\n  builder: ColorStringBuilder,\n  resourceChanges: WhatIfChange[],\n): void {\n  builder.appendLine().append(\"Resource changes: \");\n\n  if (!resourceChanges.length) {\n    builder.append(\"no change.\");\n    return;\n  }\n\n  const sortedResourceChanges = resourceChanges.sort(\n    (a, b) =>\n      changeTypeToWeight[a.changeType] - changeTypeToWeight[b.changeType],\n  );\n  const resourceChangesByChangeType = groupBy(\n    sortedResourceChanges,\n    x => x.changeType,\n  );\n  const countByChangeType = entries(resourceChangesByChangeType)\n    .map(([key, value]) => ({ key, count: value.length }))\n    .filter(x => x.count > 0);\n  const changeTypeStats = countByChangeType.map(x =>\n    formatChangeTypeCount(x.key, x.count),\n  );\n\n  builder.append(changeTypeStats.join(\", \")).append(\".\");\n}\n\nfunction formatChangeTypeCount(changeType: ChangeType, count: number): string {\n  switch (changeType) {\n    case \"Create\":\n      return `${count} to create`;\n    case \"Delete\":\n      return `${count} to delete`;\n    case \"Deploy\":\n      return `${count} to deploy`;\n    case \"Modify\":\n      return `${count} to modify`;\n    case \"Ignore\":\n      return `${count} to ignore`;\n    case \"NoChange\":\n      return `${count} no change`;\n    case \"Unsupported\":\n      return `${count} unsupported`;\n    default:\n      throw new Error(`Invalid ChangeType: ${changeType}`);\n  }\n}\n\nfunction formatResourceChanges(\n  builder: ColorStringBuilder,\n  resourceChanges: WhatIfChange[],\n): void {\n  if (!resourceChanges.length) return;\n\n  const numScopes = new Set(resourceChanges.map(getScopeUppercase)).size;\n  const resourceChangesByScope = groupBy(\n    resourceChanges.sort((a, b) =>\n      getScopeUppercase(a).localeCompare(getScopeUppercase(b)),\n    ),\n    getScopeUppercase,\n  );\n\n  builder.appendLine();\n  builder.appendLine(\n    `The deployment will update the following ${numScopes === 1 ? \"scope:\" : \"scopes:\"}`,\n  );\n\n  for (const [, resourceChangesInScope] of entries(resourceChangesByScope)) {\n    const scope = getScope(resourceChangesInScope[0]);\n    formatResourceChangesInScope(builder, scope, resourceChangesInScope);\n  }\n}\n\nfunction formatResourceChangesInScope(\n  builder: ColorStringBuilder,\n  scope: string,\n  resourceChangesInScope: WhatIfChange[],\n): void {\n  builder.appendLine().appendLine(`Scope: ${scope}`);\n\n  const sortedResourceChanges = resourceChangesInScope.sort(\n    (a, b) =>\n      changeTypeToWeight[a.changeType] - changeTypeToWeight[b.changeType],\n  );\n\n  const grouped = groupBy(sortedResourceChanges, x => x.changeType);\n  for (const [changeType, resourceChanges] of entries(grouped)) {\n    builder.withColorScope(changeTypeToColor[changeType], () => {\n      for (const resourceChange of resourceChanges) {\n        const isLast =\n          resourceChange ===\n          sortedResourceChanges[sortedResourceChanges.length - 1];\n        formatResourceChange(builder, resourceChange, isLast);\n      }\n    });\n  }\n}\n\nfunction formatResourceChange(\n  builder: ColorStringBuilder,\n  resourceChange: WhatIfChange,\n  isLast: boolean,\n): void {\n  const changeType = resourceChange.changeType;\n  const relativeResourceId = getRelativeResourceId(resourceChange);\n  const apiVersion = getApiVersion(resourceChange);\n\n  builder.appendLine();\n  formatResourceChangePath(builder, changeType, relativeResourceId, apiVersion);\n\n  if (changeType === \"Create\" && resourceChange.after) {\n    formatJsonValue(builder, resourceChange.after, undefined, undefined, 2);\n  } else if (changeType === \"Delete\" && resourceChange.before) {\n    formatJsonValue(builder, resourceChange.before, undefined, undefined, 2);\n  } else if (resourceChange.delta) {\n    const delta = resourceChange.delta;\n    builder.withColorScope(Color.Reset, () => {\n      builder.appendLine();\n      formatPropertyChanges(builder, sortChanges(delta));\n    });\n  } else if (isLast) {\n    builder.appendLine();\n  }\n}\n\nfunction formatResourceChangePath(\n  builder: ColorStringBuilder,\n  changeType: ChangeType,\n  resourceChangeId: string,\n  apiVersion?: string,\n): void {\n  formatPath(\n    builder,\n    resourceChangeId,\n    0,\n    1,\n    builder => formatResourceChangeType(builder, changeType),\n    builder => formatResourceChangeApiVersion(builder, apiVersion),\n  );\n}\n\nfunction formatResourceChangeType(\n  builder: ColorStringBuilder,\n  changeType: ChangeType,\n): void {\n  const changeSymbol = changeTypeToSymbol[changeType];\n  builder.append(changeSymbol).append(Symbol.WhiteSpace);\n}\n\nfunction formatResourceChangeApiVersion(\n  builder: ColorStringBuilder,\n  apiVersion?: string,\n): void {\n  if (!apiVersion) return;\n\n  builder.withColorScope(Color.Reset, () => {\n    builder.append(Symbol.WhiteSpace);\n    builder.append(Symbol.LeftSquareBracket);\n    builder.append(apiVersion);\n    builder.append(Symbol.RightSquareBracket);\n  });\n}\n\nfunction formatPropertyChanges(\n  builder: ColorStringBuilder,\n  propertyChanges: WhatIfPropertyChange[],\n  indentLevel: number = 2,\n): void {\n  const maxPathLength = getMaxPathLengthFromPropertyChanges(propertyChanges);\n\n  for (const propertyChange of propertyChanges) {\n    formatPropertyChange(builder, propertyChange, maxPathLength, indentLevel);\n    builder.appendLine();\n  }\n}\n\nfunction formatPropertyChange(\n  builder: ColorStringBuilder,\n  propertyChange: WhatIfPropertyChange,\n  maxPathLength: number,\n  indentLevel: number,\n): void {\n  const propertyChangeType = propertyChange.propertyChangeType;\n  const before = propertyChange.before;\n  const after = propertyChange.after;\n  const children = propertyChange.children || [];\n\n  switch (propertyChangeType) {\n    case \"Create\":\n      formatPropertyChangePath(\n        builder,\n        propertyChange,\n        propertyChange.after,\n        maxPathLength,\n        indentLevel,\n      );\n      formatPropertyCreate(builder, after, indentLevel + 1);\n      break;\n    case \"Delete\":\n      formatPropertyChangePath(\n        builder,\n        propertyChange,\n        propertyChange.before,\n        maxPathLength,\n        indentLevel,\n      );\n      formatPropertyDelete(builder, before, indentLevel + 1);\n      break;\n    case \"Modify\":\n      formatPropertyChangePath(\n        builder,\n        propertyChange,\n        propertyChange.before,\n        maxPathLength,\n        indentLevel,\n      );\n      formatPropertyModify(builder, before, after, children, indentLevel + 1);\n      break;\n    case \"Array\":\n      formatPropertyChangePath(\n        builder,\n        propertyChange,\n        propertyChange.children,\n        maxPathLength,\n        indentLevel,\n      );\n      formatPropertyArrayChange(\n        builder,\n        propertyChange,\n        children,\n        indentLevel + 1,\n      );\n      break;\n    case \"NoEffect\":\n      formatPropertyChangePath(\n        builder,\n        propertyChange,\n        propertyChange.after,\n        maxPathLength,\n        indentLevel,\n      );\n      formatPropertyNoEffect(builder, after, indentLevel + 1);\n      break;\n    default:\n      throw new Error(`Unknown property change type: ${propertyChangeType}.`);\n  }\n}\n\nfunction formatPropertyChangePath(\n  builder: ColorStringBuilder,\n  propertyChange: WhatIfPropertyChange,\n  value: UnknownValue,\n  maxPathLength: number,\n  indentLevel: number,\n): void {\n  if (!propertyChange.path) return;\n\n  const path = propertyChange.path;\n  const propertyChangeType = propertyChange.propertyChangeType;\n\n  let paddingWidth = maxPathLength - path.length + 1;\n\n  if (isNonEmptyArray(value)) {\n    paddingWidth = 1;\n  } else if (isNonEmptyObject(value)) {\n    paddingWidth = 0;\n  } else if (propertyChangeType === \"Modify\" && propertyChange.children) {\n    paddingWidth = 0; // Has nested changes.\n  }\n\n  formatPath(\n    builder,\n    path,\n    paddingWidth,\n    indentLevel,\n    builder => formatPropertyChangeType(builder, propertyChangeType),\n    formatColon,\n  );\n}\n\nfunction formatPropertyChangeType(\n  builder: ColorStringBuilder,\n  propertyChangeType: PropertyChangeType,\n): void {\n  const propertyChangeSymbol = propertyChangeTypeToSymbol[propertyChangeType];\n  const propertyChangeColor = propertyChangeTypeToColor[propertyChangeType];\n  builder\n    .append(propertyChangeSymbol, propertyChangeColor)\n    .append(Symbol.WhiteSpace);\n}\n\nfunction formatPropertyNoEffect(\n  builder: ColorStringBuilder,\n  value: UnknownValue,\n  indentLevel: number,\n): void {\n  builder.withColorScope(propertyChangeTypeToColor[\"NoEffect\"], () => {\n    formatJsonValue(builder, value, undefined, undefined, indentLevel);\n  });\n}\n\nfunction formatPropertyCreate(\n  builder: ColorStringBuilder,\n  value: UnknownValue,\n  indentLevel: number,\n): void {\n  builder.withColorScope(propertyChangeTypeToColor[\"Create\"], () => {\n    formatJsonValue(builder, value, undefined, undefined, indentLevel);\n  });\n}\n\nfunction formatPropertyDelete(\n  builder: ColorStringBuilder,\n  value: UnknownValue,\n  indentLevel: number,\n): void {\n  builder.withColorScope(propertyChangeTypeToColor[\"Delete\"], () => {\n    formatJsonValue(builder, value, undefined, undefined, indentLevel);\n  });\n}\n\nfunction fixSdkDeltaFormattingBug(value: UnknownValue): UnknownValue {\n  // For some reason, the node SDK appears to conver strings incorrectly inside the \"delta\" object.\n  // Instead of returning \"foo\", we get {0: 'f', 1: 'o', 2: 'o' }. This function works around this bug, by\n  // trying to detect this heuristically, and convert back into the correct string format.\n  // See https://github.com/Azure/bicep-deploy/issues/71 for more info.\n  if (\n    value === null ||\n    typeof value !== \"object\" ||\n    Object.keys(value).length === 0\n  ) {\n    return value;\n  }\n\n  let fixedString = \"\";\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const objValue = value as any;\n  const keys = Object.keys(objValue);\n  for (let i = 0; i < keys.length; i++) {\n    const nextChar = objValue[i.toString()];\n    // be specific here with the check, to minimize the chance of\n    // accidentally trying to convert a value that genuinely should be an object.\n    if (typeof nextChar !== \"string\" || nextChar.length !== 1) {\n      return value;\n    }\n\n    fixedString += nextChar;\n  }\n\n  return fixedString;\n}\n\nfunction formatPropertyModify(\n  builder: ColorStringBuilder,\n  before: UnknownValue,\n  after: UnknownValue,\n  children: WhatIfPropertyChange[],\n  indentLevel: number,\n): void {\n  if (children && children.length > 0) {\n    // Has nested changes.\n    builder.appendLine().appendLine();\n    formatPropertyChanges(builder, sortChanges(children), indentLevel);\n  } else {\n    formatPropertyDelete(builder, before, indentLevel);\n\n    // Space before =>\n    if (isNonEmptyObject(before)) {\n      builder.appendLine();\n      formatIndent(builder, indentLevel);\n    } else {\n      builder.append(Symbol.WhiteSpace);\n    }\n\n    builder.append(\"=>\");\n\n    // Space after =>\n    if (!isNonEmptyObject(after)) {\n      builder.append(Symbol.WhiteSpace);\n    }\n\n    formatPropertyCreate(builder, after, indentLevel);\n\n    if (!isLeaf(before) && isLeaf(after)) {\n      builder.appendLine();\n    }\n  }\n}\n\nfunction formatPropertyArrayChange(\n  builder: ColorStringBuilder,\n  parentPropertyChange: WhatIfPropertyChange,\n  propertyChanges: WhatIfPropertyChange[],\n  indentLevel: number,\n): void {\n  if (!parentPropertyChange.path) {\n    // The parent change doesn't have a path, which means the current\n    // array change is a nested change. Decrease indent level.\n    indentLevel -= 1;\n    formatIndent(builder, indentLevel);\n  }\n\n  if (!propertyChanges || propertyChanges.length === 0) {\n    builder.appendLine(\"[]\");\n    return;\n  }\n\n  // [\n  builder.append(Symbol.LeftSquareBracket).appendLine();\n\n  formatPropertyChanges(builder, sortChanges(propertyChanges), indentLevel);\n\n  // ]\n  formatIndent(builder, indentLevel);\n  builder.append(Symbol.RightSquareBracket);\n}\n\nfunction getApiVersion(resourceChange: WhatIfChange): string | undefined {\n  if (resourceChange.before) {\n    return resourceChange.before.apiVersion as string;\n  }\n  if (resourceChange.after) {\n    return resourceChange.after.apiVersion as string;\n  }\n}\n\nfunction getScope(resourceChange: WhatIfChange): string {\n  if (!resourceChange.resourceId) {\n    throw new Error(\n      \"Extensible resource what-if is not currently supported by this Action. Please raise an issue: https://github.com/Azure/bicep-deploy/issues.\",\n    );\n  }\n\n  const [scope] = splitResourceId(resourceChange.resourceId);\n  return scope;\n}\n\nfunction getScopeUppercase(resourceChange: WhatIfChange): string {\n  return getScope(resourceChange).toUpperCase();\n}\n\nfunction getRelativeResourceId(resourceChange: WhatIfChange): string {\n  if (!resourceChange.resourceId) {\n    throw new Error(\n      \"Extensible resource what-if is not currently supported by this Action. Please raise an issue: https://github.com/Azure/bicep-deploy/issues.\",\n    );\n  }\n\n  const [, relativeResourceId] = splitResourceId(resourceChange.resourceId);\n  return relativeResourceId;\n}\n\nfunction getMaxPathLengthFromPropertyChanges(\n  propertyChanges: WhatIfPropertyChange[],\n): number {\n  if (!propertyChanges || propertyChanges.length === 0) {\n    return 0;\n  }\n\n  const filteredPropertyChanges = propertyChanges.filter(\n    shouldConsiderPropertyChangePath,\n  );\n  const pathLengths = filteredPropertyChanges.map(x => x.path.length);\n\n  return Math.max(...pathLengths, 0);\n}\n\nfunction shouldConsiderPropertyChangePath(\n  propertyChange: WhatIfPropertyChange,\n): boolean {\n  const propertyChangeType = propertyChange.propertyChangeType;\n\n  if (propertyChangeType === \"Create\") {\n    return isLeaf(propertyChange.after);\n  }\n\n  if (propertyChangeType === \"Delete\" || propertyChangeType === \"Modify\") {\n    return isLeaf(propertyChange.before);\n  }\n\n  return !propertyChange.children;\n}\n\nfunction formatJsonValue(\n  builder: ColorStringBuilder,\n  value: UnknownValue,\n  path: string = \"\",\n  maxPathLength: number = 0,\n  indentLevel: number = 0,\n): void {\n  value = fixSdkDeltaFormattingBug(value);\n\n  if (isLeaf(value)) {\n    const pathLength = maxPathLength - path.length + 1;\n    formatJsonPath(builder, path, pathLength > 0 ? pathLength : 0, indentLevel);\n    formatLeaf(builder, value);\n  } else if (isNonEmptyArray(value)) {\n    formatJsonPath(builder, path, 1, indentLevel);\n    formatNonEmptyArray(builder, value, indentLevel);\n  } else if (isNonEmptyObject(value)) {\n    formatNonEmptyObject(builder, value, path, maxPathLength, indentLevel);\n  } else {\n    throw new Error(`Invalid JSON value: ${value}`);\n  }\n}\n\nfunction formatLeaf(builder: ColorStringBuilder, value: UnknownValue): void {\n  if (value === null) {\n    builder.append(\"null\");\n  } else if (typeof value === \"boolean\") {\n    builder.append(String(value).toLowerCase());\n  } else if (typeof value === \"string\") {\n    builder.append(Symbol.Quote).append(value).append(Symbol.Quote);\n  } else if (Array.isArray(value) && value.length === 0) {\n    builder.append(\"[]\");\n  } else if (typeof value === \"object\") {\n    builder.append(\"{}\");\n  } else {\n    builder.append(String(value));\n  }\n}\n\nfunction formatNonEmptyArray(\n  builder: ColorStringBuilder,\n  value: UnknownValue[],\n  indentLevel: number,\n): void {\n  builder.append(Symbol.LeftSquareBracket, Color.Reset).appendLine();\n\n  const maxPathLength = getMaxPathLengthFromArray(value);\n\n  value.forEach((childValue, index) => {\n    const childPath = String(index);\n\n    if (isNonEmptyObject(childValue)) {\n      formatJsonPath(builder, childPath, 0, indentLevel + 1);\n      formatNonEmptyObject(\n        builder,\n        childValue,\n        undefined,\n        undefined,\n        indentLevel + 1,\n      );\n    } else {\n      formatJsonValue(\n        builder,\n        childValue,\n        childPath,\n        maxPathLength,\n        indentLevel + 1,\n      );\n    }\n\n    builder.appendLine();\n  });\n\n  formatIndent(builder, indentLevel);\n  builder.append(Symbol.RightSquareBracket, Color.Reset);\n}\n\nfunction formatNonEmptyObject(\n  builder: ColorStringBuilder,\n  value: Record<string, UnknownValue>,\n  path: string = \"\",\n  maxPathLength: number = 0,\n  indentLevel: number = 0,\n): void {\n  const isRoot = !path;\n\n  if (!path) {\n    // Root object.\n    builder.appendLine().appendLine();\n    maxPathLength = getMaxPathLengthFromObject(value);\n    indentLevel += 1;\n  }\n\n  for (const [childPath, childValue] of entries(value)) {\n    const formattedChildPath = isRoot\n      ? childPath\n      : `${path}${Symbol.Dot}${childPath}`;\n    formatJsonValue(\n      builder,\n      childValue,\n      formattedChildPath,\n      maxPathLength,\n      indentLevel,\n    );\n\n    if (!isNonEmptyObject(childValue)) {\n      builder.appendLine();\n    }\n  }\n}\n\nfunction formatJsonPath(\n  builder: ColorStringBuilder,\n  path: string,\n  paddingWidth: number,\n  indentLevel: number,\n): void {\n  formatPath(builder, path, paddingWidth, indentLevel, undefined, formatColon);\n}\n\nfunction formatPath(\n  builder: ColorStringBuilder,\n  path: string,\n  paddingWidth: number,\n  indentLevel: number,\n  formatHead?: (builder: ColorStringBuilder) => void,\n  formatTail?: (builder: ColorStringBuilder) => void,\n): void {\n  if (!path) return;\n\n  formatIndent(builder, indentLevel);\n\n  if (formatHead) {\n    formatHead(builder);\n  }\n\n  builder.append(path);\n\n  if (formatTail) {\n    formatTail(builder);\n  }\n\n  builder.append(\" \".repeat(paddingWidth));\n}\n\nfunction formatColon(builder: ColorStringBuilder): void {\n  builder.append(Symbol.Colon, Color.Reset);\n}\n\nfunction formatIndent(\n  builder: ColorStringBuilder,\n  indentLevel: number = 1,\n): void {\n  builder.append(\" \".repeat(2 * indentLevel));\n}\n\nfunction getMaxPathLengthFromArray(value: UnknownValue[]): number {\n  let maxLengthIndex = 0;\n\n  value.forEach((childValue, index) => {\n    if (isLeaf(childValue)) {\n      maxLengthIndex = index;\n    }\n  });\n\n  return String(maxLengthIndex).length;\n}\n\nfunction getMaxPathLengthFromObject(\n  value: Record<string, UnknownValue>,\n): number {\n  let maxPathLength = 0;\n\n  for (const [key, childValue] of entries(value)) {\n    if (isNonEmptyArray(childValue)) {\n      continue; // Ignore array paths\n    }\n\n    const currentPathLength = isNonEmptyObject(childValue)\n      ? key.length + 1 + getMaxPathLengthFromObject(childValue)\n      : key.length;\n\n    maxPathLength = Math.max(maxPathLength, currentPathLength);\n  }\n\n  return maxPathLength;\n}\n\nfunction isLeaf(value: UnknownValue): boolean {\n  return (\n    value === null ||\n    value === undefined ||\n    typeof value === \"boolean\" ||\n    typeof value === \"number\" ||\n    typeof value === \"string\" ||\n    (Array.isArray(value) && value.length === 0) ||\n    (typeof value === \"object\" && value && Object.keys(value).length === 0)\n  );\n}\n\nfunction isNonEmptyArray(value: UnknownValue): value is UnknownValue[] {\n  return Array.isArray(value) && value.length > 0;\n}\n\nfunction isNonEmptyObject(\n  value: UnknownValue,\n): value is Record<string, UnknownValue> {\n  return (\n    typeof value === \"object\" && value !== null && Object.keys(value).length > 0\n  );\n}\n\nfunction sortChanges(changes: WhatIfPropertyChange[]) {\n  return changes\n    .slice()\n    .sort(\n      (a, b) =>\n        propertyChangeTypeToWeight[a.propertyChangeType] -\n          propertyChangeTypeToWeight[b.propertyChangeType] ||\n        a.path.localeCompare(b.path),\n    );\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction groupBy<K extends keyof any, T>(\n  array: T[],\n  getKey: (item: T) => K,\n): Record<K, T[]> {\n  return array.reduce(\n    (result, item) => {\n      const key = getKey(item);\n      (result[key] = result[key] || []).push(item);\n      return result;\n    },\n    {} as Record<K, T[]>,\n  );\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction entries<K extends keyof any, T>(record: Record<K, T>): [K, T][] {\n  return Object.entries(record) as [K, T][];\n}\n\nfunction splitResourceId(resourceId: string): [string, string] {\n  const providers = \"/providers/\";\n  const providersIndex = resourceId.lastIndexOf(providers);\n  if (providersIndex === -1) {\n    const rgMatches = [\n      ...resourceId.matchAll(\n        /^(\\/subscriptions\\/[^/]+)\\/(resourceGroups\\/[^/]+)$/gi,\n      ),\n    ];\n\n    if (rgMatches[0]) {\n      return [rgMatches[0][1], rgMatches[0][2]];\n    }\n\n    return [\"/\", resourceId.substring(1)];\n  }\n\n  return [\n    resourceId.substring(0, providersIndex),\n    resourceId.substring(providersIndex + providers.length),\n  ];\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nexport interface Logger {\n  isDebugEnabled(): boolean;\n  debug(message: string): void;\n  logInfo(message: string): void;\n  logWarning(message: string): void;\n  logError(message: string): void;\n  logInfoRaw(message: string): void;\n}\n\nexport type ColorMode = \"off\" | \"ansii\" | \"debug\"; // debug is just used for unit testing\n\nexport enum Color {\n  Reset = \"\\x1b[0m\",\n  Red = \"\\x1b[31m\",\n  Green = \"\\x1b[32m\",\n  Yellow = \"\\x1b[33m\",\n  Blue = \"\\x1b[34m\",\n  Magenta = \"\\x1b[35m\",\n  Cyan = \"\\x1b[36m\",\n  White = \"\\x1b[37m\",\n}\n\nconst colorToName: Record<Color, string> = {\n  \"\\u001b[0m\": \"Reset\",\n  \"\\u001b[31m\": \"Red\",\n  \"\\u001b[32m\": \"Green\",\n  \"\\u001b[33m\": \"Yellow\",\n  \"\\u001b[34m\": \"Blue\",\n  \"\\u001b[35m\": \"Magenta\",\n  \"\\u001b[36m\": \"Cyan\",\n  \"\\u001b[37m\": \"White\",\n};\n\nexport function colorize(message: string, color: Color) {\n  return message\n    .split(\"\\n\")\n    .map(line => `${color}${line}${Color.Reset}`)\n    .join(\"\\n\");\n}\n\nexport function removeColors(message: string) {\n  for (const color in colorToName) {\n    message = message.replaceAll(color, \"\");\n  }\n\n  return message;\n}\n\nexport function getColorString(colorMode: ColorMode, color: Color): string {\n  switch (colorMode) {\n    case \"off\":\n      return \"\";\n    case \"ansii\":\n      return color;\n    case \"debug\":\n      return `<${colorToName[color].toUpperCase()}>`;\n  }\n\n  return color;\n}\n\nexport class ColorStringBuilder {\n  private colorStack: Color[] = [];\n  private buffer: string = \"\";\n  constructor(private colorMode: ColorMode) {}\n\n  append(value: string, color?: Color): this {\n    if (color) {\n      this.pushColor(color);\n    }\n\n    this.buffer += value;\n\n    if (color) {\n      this.popColor();\n    }\n\n    return this;\n  }\n\n  appendLine(value: string = \"\"): this {\n    return this.append(value + \"\\n\");\n  }\n\n  withColorScope(color: Color, action: () => void): void {\n    this.pushColor(color);\n    action();\n    this.popColor();\n  }\n\n  private pushColor(color: Color) {\n    this.colorStack.push(color);\n    this.buffer += getColorString(this.colorMode, color);\n  }\n\n  private popColor() {\n    this.colorStack.pop();\n    const prevColor =\n      this.colorStack[this.colorStack.length - 1] ?? Color.Reset;\n    this.buffer += getColorString(this.colorMode, prevColor);\n  }\n\n  build(): string {\n    return this.buffer;\n  }\n}\n"],
  "mappings": "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",
  "names": ["whatif_exports", "__export", "formatJson", "formatWhatIfOperationResult", "__toCommonJS", "colorToName", "getColorString", "colorMode", "color", "colorToName", "ColorStringBuilder", "value", "action", "prevColor", "changeTypeToColor", "propertyChangeTypeToColor", "changeTypeToSymbol", "propertyChangeTypeToSymbol", "changeTypeToWeight", "propertyChangeTypeToWeight", "propertyChangeToChangeType", "formatJson", "value", "colorMode", "builder", "ColorStringBuilder", "formatJsonValue", "formatWhatIfOperationResult", "whatIfOperationResult", "formatNoiseNotice", "formatChangeTypeLegend", "formatResourceChanges", "formatResourceChangesStats", "resourceChanges", "changeTypeSet", "populateChangeTypeSet", "propertyChanges", "propertyChange", "propertyChangeType", "resourceChange", "changeTypes", "b", "changeType", "changeTypeSymbol", "changeTypeColor", "formatIndent", "sortedResourceChanges", "a", "resourceChangesByChangeType", "groupBy", "x", "changeTypeStats", "entries", "key", "formatChangeTypeCount", "count", "numScopes", "getScopeUppercase", "resourceChangesByScope", "resourceChangesInScope", "scope", "getScope", "formatResourceChangesInScope", "grouped", "isLast", "formatResourceChange", "relativeResourceId", "getRelativeResourceId", "apiVersion", "getApiVersion", "formatResourceChangePath", "delta", "formatPropertyChanges", "sortChanges", "resourceChangeId", "formatPath", "formatResourceChangeType", "formatResourceChangeApiVersion", "changeSymbol", "indentLevel", "maxPathLength", "getMaxPathLengthFromPropertyChanges", "formatPropertyChange", "before", "after", "children", "formatPropertyChangePath", "formatPropertyCreate", "formatPropertyDelete", "formatPropertyModify", "formatPropertyArrayChange", "formatPropertyNoEffect", "path", "paddingWidth", "isNonEmptyArray", "isNonEmptyObject", "formatPropertyChangeType", "formatColon", "propertyChangeSymbol", "propertyChangeColor", "fixSdkDeltaFormattingBug", "fixedString", "objValue", "keys", "i", "nextChar", "isLeaf", "parentPropertyChange", "splitResourceId", "pathLengths", "shouldConsiderPropertyChangePath", "pathLength", "formatJsonPath", "formatLeaf", "formatNonEmptyArray", "formatNonEmptyObject", "getMaxPathLengthFromArray", "childValue", "index", "childPath", "isRoot", "getMaxPathLengthFromObject", "formattedChildPath", "formatHead", "formatTail", "maxLengthIndex", "currentPathLength", "changes", "array", "getKey", "result", "item", "record", "resourceId", "providers", "providersIndex", "rgMatches"]
}
